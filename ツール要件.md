# **ドキュメント比較ツール 仕様提案**

## **1\. はじめに**

本ドキュメントは、2つのドキュメントを比較し、追加・削除・変更箇所を抽出してMarkdown形式の新旧比較表を作成するPythonツールの仕様を提案するものです。LangChain、LangGraph、Streamlit、およびOpenAIの埋め込みモデルとGPT-4.1モデルの活用を前提とします。

## **2\. ツールの概要とアーキテクチャ**

### **2.1. 使用技術スタック**

* **言語:** Python  
* **LLMオーケストレーション:** LangChain, LangGraph  
* **UI:** Streamlit  
* **LLM:** OpenAI (埋め込みモデル, GPT-4.1)  
* **その他ライブラリ:** numpy (コサイン類似度計算など)

### **2.2. 全体的な処理フロー**

以下に、ツールの大まかな処理フローを示します。このフローはLangGraphを用いて構築されます。

graph TD  
    A\[UI: ドキュメント1入力\] \--\> C{比較実行};  
    B\[UI: ドキュメント2入力\] \--\> C;  
    C \--\> D\[Step 1: 前処理\];  
    D \--\> E\[Step 2: ベクトル化\];  
    E \--\> F\[Step 3: 類似チャンクペア特定\];  
    F \--\> G\[Step 4: 比較分析 & 結果生成\];  
    G \--\> H\[UI: Markdown結果表示\];

    subgraph LangGraph Workflow  
        direction LR  
        S1\[ドキュメント読み込み/チャンク化\] \--\> S2\[文分割\];  
        S2 \--\> S3\[各文をベクトル化\];  
        S3 \--\> S4\[チャンクペア候補生成\];  
        S4 \--\> S5{類似度判定};  
        S5 \-- 閾値以上 \--\> S6\[類似チャンクペア確定\];  
        S5 \-- 閾値未満 \--\> S7\[ペアなしとして処理\];  
        S6 \--\> S8\[GPT-4.1で比較分析\];  
        S7 \--\> S8;  
        S8 \--\> S9\[Markdown形式で結果統合\];  
    end

1. **ドキュメント入力 (Streamlit):** ユーザーが比較したい2つのドキュメント（旧・新）をStreamlitのUI経由で入力します。  
2. **前処理 (LangChain/Python):**  
   * 各ドキュメントを段落（チャンク）ごとに分割します。  
   * 各チャンクをさらに文単位（「。」で区切る）に分割します。  
3. **ベクトル化 (OpenAI Embedding Model):**  
   * 分割された各文をOpenAIの埋め込みモデル（例: text-embedding-3-small）を使用してベクトル化します。  
4. **類似チャンクペアの特定 (Python/numpy):**  
   * 旧ドキュメントの各チャンク内の文ベクトルと、新ドキュメントの各チャンク内の文ベクトルの間でコサイン類似度を総当たりで計算します。  
   * 事前に設定された固定閾値（例: 0.8）よりも高い類似度を持つ文のペアを抽出します。  
   * これらの文ペアが含まれるチャンク同士を「関連チャンクペア」として特定します。この際、1:1、1:N（旧1:新N）、N:1（旧N:新1）の関連付けを考慮します。  
5. **比較分析と結果生成 (OpenAI GPT-4.1 & LangChain):**  
   * 特定された関連チャンクペア、および関連が見つからなかったチャンク（追加または削除されたチャンク）をGPT-4.1に入力します。  
   * GPT-4.1は、チャンクペアの内容を比較し、「変更」の詳細を分析します。変更がない場合はその旨を、変更がある場合は具体的な変更点を記述します。  
   * 関連が見つからなかったチャンクは、「追加」または「削除」として分類します。  
   * これらの分析結果を統合し、Markdown形式の新旧比較表を生成します。  
6. **結果表示 (Streamlit):** 生成されたMarkdownをStreamlitのUIに表示します。

## **3\. 主要な処理ステップ詳細**

### **3.1. ドキュメント入力 (Streamlit)**

* StreamlitのUI上に、2つのテキストエリア（またはファイルアップロード機能）を設け、ユーザーが旧ドキュメントと新ドキュメントを入力できるようにします。  
* 「比較開始」ボタンを配置し、クリックすると処理が開始されます。

### **3.2. 前処理：チャンク化と文分割**

* **段落（チャンク）分割:**  
  * ドキュメント内の連続する空行（例: 2つ以上の連続した改行）を段落の区切りと見なしてチャンク化します。  
  * または、一定の文字数や意味的な区切りを考慮したより高度なチャンキング手法も検討可能です（初期は空行ベースでシンプルに）。  
  * 各チャンクには一意のID（例: old\_chunk\_1, new\_chunk\_1）を付与します。  
* **文分割:**  
  * 各チャンク内のテキストを「。」を区切り文字として文に分割します。  
  * 「。」が文末以外で使われるケース（例: 三点リーダー、略称など）への対応は、初期フェーズでは考慮せず、必要に応じて改善します。

### **3.3. ベクトル化 (OpenAI Embedding Model)**

* 分割された各文に対して、OpenAIの埋め込みモデル（例: text-embedding-3-small や text-embedding-ada-002）を呼び出し、文ベクトルを取得します。  
* これらのベクトルは後段の類似度計算に使用されます。

### **3.4. 類似チャンクペアの特定**

* **ロジック:**  
  1. 旧ドキュメントのチャンクAに含まれる各文 s\_a\_i と、新ドキュメントのチャンクBに含まれる各文 s\_b\_j について、それぞれの文ベクトル間のコサイン類似度を計算します。  
  2. 類似度が設定した閾値（例: 0.8）を超えた場合、その文ペア (s\_a\_i, s\_b\_j) は「類似文ペア」と見なします。  
  3. チャンクAとチャンクBの間に1つでも「類似文ペア」が存在する場合、チャンクAとチャンクBを「関連チャンクペア候補」とします。  
* **1:N および N:1 のハンドリング:**  
  * ある旧チャンク old\_C1 内の文が、新チャンク new\_C\_X 内の文と類似し、かつ new\_C\_Y 内の文とも類似する場合、(old\_C1, new\_C\_X) と (old\_C1, new\_C\_Y) の両方をペア候補とします (1:N)。  
  * 同様に、旧チャンク old\_C\_P と old\_C\_Q の両方が、新チャンク new\_C1 とそれぞれ類似文ペアを持つ場合、(old\_C\_P, new\_C1) と (old\_C\_Q, new\_C1) をペア候補とします (N:1)。  
  * 最終的なペアリングは、最も確からしい組み合わせを選択するロジック（例：類似文ペアの数や平均類似度などに基づく）を導入することも考えられますが、初期は閾値を超えたペアをすべて抽出します。  
* **ペアにならなかったチャンク:**  
  * 旧ドキュメント側でどの新チャンクともペアにならなかったものは「削除候補」。  
  * 新ドキュメント側でどの旧チャンクともペアにならなかったものは「追加候補」。

### **3.5. 比較分析と結果生成 (OpenAI GPT-4.1)**

* **入力プロンプトの設計方針:**  
  * **役割設定:** 「あなたは、2つのテキストチャンクを比較し、変更点、追加点、削除点を正確に指摘する専門家です。」  
  * **指示:**  
    * 「以下の旧チャンクと新チャンクを比較してください。」  
    * 「変更があった場合は、具体的に何がどのように変わったのかを詳細に説明してください。表現の変更、内容の追加/削除、構成の変更などを区別してください。」  
    * 「変更がない場合は、『変更なし』と明確に記述してください。」  
    * 「追加されたチャンクの場合は、その内容を要約してください。」  
    * 「削除されたチャンクの場合は、その内容を要約してください。」  
    * 「出力はMarkdown形式で、以下のセクションを含めてください: 変更の種類（変更、追加、削除、変更なし）、変更前（該当する場合）、変更後（該当する場合）、分析/要約。」  
  * **コンテキスト提供:**  
    * ペアとなる旧チャンクのテキストと新チャンクのテキスト（1:1の場合）。  
    * 1:NやN:1の場合は、関連する複数のチャンクテキストを提示し、それらの関係性（分割、統合など）も推測させる。  
    * 追加/削除の場合は、該当するチャンクのテキストのみを提示。  
* **比較結果の判断基準:**  
  * **変更:** 関連チャンクペアが存在し、内容に差異があるとGPT-4.1が判断した場合。  
  * **追加:** 新ドキュメントにのみ存在し、旧ドキュメントに対応する関連チャンクが見つからないチャンク。  
  * **削除:** 旧ドキュメントにのみ存在し、新ドキュメントに対応する関連チャンクが見つからないチャンク。  
* **Markdown形式での出力例 (再掲):**  
  \# ドキュメント比較結果

  \#\# 1\. 比較: 旧チャンクID: old\_chunk\_1 vs 新チャンクID: new\_chunk\_3

  \* \*\*種類:\*\* 変更  
  \* \*\*変更前 (old\_chunk\_1):\*\*  
      旧チャンクのテキスト内容...  
  \* \*\*変更後 (new\_chunk\_3):\*\*  
      新チャンクのテキスト内容...  
  \* \*\*分析:\*\*  
      GPT-4.1による具体的な変更点の分析結果...

  \#\# 2\. 追加: 新チャンクID: new\_chunk\_5

  \* \*\*種類:\*\* 追加  
  \* \*\*内容 (new\_chunk\_5):\*\*  
      追加されたチャンクのテキスト内容...  
  \* \*\*要約:\*\*  
      GPT-4.1による追加内容の要約...

  \#\# 3\. 削除: 旧チャンクID: old\_chunk\_7

  \* \*\*種類:\*\* 削除  
  \* \*\*内容 (old\_chunk\_7):\*\*  
      削除されたチャンクのテキスト内容...  
  \* \*\*要約:\*\*  
      GPT-4.1による削除内容の要約...

  \#\# 4\. 比較 (1:N): 旧チャンクID: old\_chunk\_2 vs 新チャンクID: new\_chunk\_1, new\_chunk\_2

  \* \*\*種類:\*\* 分割・変更  
  \* \*\*変更前 (old\_chunk\_2):\*\*  
      旧チャンク2の内容...  
  \* \*\*変更後 (new\_chunk\_1):\*\*  
      新チャンク1の内容...  
  \* \*\*変更後 (new\_chunk\_2):\*\*  
      新チャンク2の内容...  
  \* \*\*分析:\*\*  
      旧チャンク2の内容が、新ドキュメントではチャンク1とチャンク2に分割され、それぞれ内容が変更されています... (GPT-4.1による分析)

  \#\# 5\. 比較 (N:1): 新チャンクID: new\_chunk\_8 vs 旧チャンクID: old\_chunk\_4, old\_chunk\_5

  \* \*\*種類:\*\* 統合・変更  
  \* \*\*変更前 (old\_chunk\_4):\*\*  
      旧チャンク4の内容...  
  \* \*\*変更前 (old\_chunk\_5):\*\*  
      旧チャンク5の内容...  
  \* \*\*変更後 (new\_chunk\_8):\*\*  
      新チャンク8の内容...  
  \* \*\*分析:\*\*  
      旧チャンク4と旧チャンク5の内容が、新ドキュメントではチャンク8に統合され、内容が変更されています... (GPT-4.1による分析)

### **3.6. 結果表示 (Streamlit)**

* 生成されたMarkdown文字列を、Streamlitの st.markdown() を使用して整形された形で表示します。

## **4\. LangGraphによる処理フローの実装方針**

LangGraphを利用して、上記の処理フローを管理し、各ステップ間のデータの受け渡しや条件分岐を制御します。

* **グラフのノード構成案:**  
  1. load\_and\_chunk\_documents: ドキュメントを読み込み、チャンクIDを付与してチャンク化、さらに文に分割するノード。  
  2. vectorize\_sentences: 各文をベクトル化するノード。  
  3. identify\_similar\_chunk\_pairs: 文ベクトル間の類似度を計算し、閾値に基づいて関連チャンクペア（1:1, 1:N, N:1）および追加/削除チャンクを特定するノード。  
  4. analyze\_changes\_with\_gpt4: 各チャンクペアまたは単独チャンクについてGPT-4.1を呼び出し、比較分析または要約を行うノード。このノードは並列実行も検討。  
  5. compile\_markdown\_report: GPT-4.1からの結果を収集し、最終的なMarkdownレポートを生成するノード。  
* **状態管理 (State):**  
  * グラフ全体で共有される状態（State）を定義します。これには以下のような情報が含まれます。  
    * original\_doc1\_chunks: 旧ドキュメントのチャンク（ID、原文、文リスト、文ベクトルリスト）  
    * original\_doc2\_chunks: 新ドキュメントのチャンク（同上）  
    * identified\_pairs: 特定されたチャンクペアのリスト \[(old\_chunk\_id, new\_chunk\_id), ...\] や \[(old\_chunk\_id, \[new\_chunk\_id1, new\_chunk\_id2\]), ...\]  
    * added\_chunks: 追加された新チャンクIDのリスト  
    * deleted\_chunks: 削除された旧チャンクIDのリスト  
    * comparison\_results: 各ペア/チャンクのGPT-4.1による分析結果（Markdown断片）  
    * final\_markdown\_report: 最終的なMarkdownレポート文字列

## **5\. Streamlit UIの設計案**

* **画面構成:**  
  * タイトル: 「ドキュメント比較ツール」  
  * 入力エリア:  
    * 左側: 「旧ドキュメント」用のテキストエリア（st.text\_area）  
    * 右側: 「新ドキュメント」用のテキストエリア（st.text\_area）  
  * 操作ボタン:  
    * 「比較実行」ボタン (st.button)  
  * 結果表示エリア:  
    * 比較結果のMarkdownを表示するエリア (st.markdown)  
    * 処理中のステータス表示（st.spinner や st.progress）  
* **操作フロー:**  
  1. ユーザーが2つのドキュメントをそれぞれのテキストエリアにペースト（またはファイルアップロード）。  
  2. 「比較実行」ボタンをクリック。  
  3. 処理中はスピナー等で待機状態を示す。  
  4. 処理完了後、結果表示エリアにMarkdown形式の比較結果が表示される。

## **6\. 考慮事項**

* **類似度閾値の調整:**  
  * 初期値は固定（例: 0.8）としますが、ドキュメントの性質やユーザーの要求に応じて調整できるように、UIに設定オプションを追加することを将来的に検討できます。  
* **大規模ドキュメントへの対応:**  
  * 非常に長いドキュメントや多数のチャンクがある場合、ベクトル化、類似度計算、GPT-4.1のAPI呼び出し回数が増加し、処理時間とコストが大きくなる可能性があります。  
  * 対策として、非同期処理の導入、ベクトル検索エンジンの利用（FAISS, Pineconeなど）、GPT呼び出しのバッチ化や並列化、より軽量なモデルの検討などが考えられます。  
* **エラーハンドリング:**  
  * API呼び出しエラー、タイムアウト、予期せぬデータ形式などに対する堅牢なエラーハンドリングをLangGraph内に実装します。  
  * ユーザーには分かりやすいエラーメッセージをUI上に表示します。  
* **段落・文分割の精度:**  
  * 現在の「空行」「。」ベースの分割はシンプルですが、ドキュメントのフォーマットによっては期待通りに機能しない場合があります。より高度な自然言語処理ライブラリ（spaCy, GiNZAなど）の利用も将来的には検討可能です。

## **7\. 今後の展望 (オプション)**

* 比較結果の差分ハイライト表示（HTMLや専用ライブラリ利用）。  
* 比較結果のフィルタリング機能（例: 「変更」のみ表示）。  
* 比較結果のファイルエクスポート機能（Markdownファイル、PDFなど）。  
* 対応フォーマットの拡充（.docx, .pdfなどからのテキスト抽出）。

この仕様提案が、具体的な開発の第一歩となれば幸いです。ご不明な点や、さらに詳細化したい点がございましたら、お気軽にお知らせください。